# Deep Dive

## Java 애플리케이션에서 스레드 안전을 보장하기 위해 해야할 것은?
#### 스레드 안전 (Thread-Safe) 이란?
> 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없는 것

- 함수 A가 스레드 1번으로부터 호출되어 실행 중일 때, 스레드 2번이 함수 A를 호출하여 동시에 실행되더라도 각 스레드에서의 함수 수행 결과가 올바르게 나오는 것

##### Thread-Safe 하지 않은 상황
예시) 공유 자원에 대한 동시 접근을 막지 않은 경우
n명이 동시에 100만원 출금 → n * 100 만원이 출금 되는 문제 발생

### 스레드의 구조
![250208_1](https://github.com/user-attachments/assets/7c062703-e65a-4dc0-b4e8-dfef8d042952)

- Stack 영역은 함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수 내 선언되는 변수 등을 저장하는 메모리 공간
- 독립적인 스택을 가졌다 → 독립적인 함수 호출이 가능하다 → 독립적인 실행 흐름이 추가된다
- 즉, 스레드는 stack을 가짐으로써 독립적인 실행 흐름을 가질 수 있게 되는 것

### Thread-Safe와 Thread-Unsafe한 코드의 특징

|Thread Safe|Thread Unsafe|
|---|---|
|두 개 이상의 스레드에서 동시에 해당 코드 실행 시 문제 발생 X|두 개 이상의 스레드에서 해당 코드 실행 시 예기치 않은 동작 발생|
|공유 자원에 대한 접근을 동기화하거나 동기성 제어 기법 사용|공유 자원에 대한 접근을 동기화하지 X, 동기화 방법이 부적절하거나, 공유 자원의 불변성을 유지하지 않음|
|전역 변수와 같은 공유 자원에 대한 접근을 제한하거나 불변성을 유지하는 등의 방법으로 **스레드 간의 경쟁 상태를 방지**|경쟁 조건이 발생하거나 교착 상태 또는 데드락 등의 문제가 발생|

> [Java에서 Thread-Safe하게 구현하기](https://velog.io/@mangoo/java-thread-safety)

### Thread-Safe 의 여부 판단 방법

1. 전역 변수나 힙, 파일과 같이 여러 스레드가 동시에 접근할 수 있는 자원을 사용하는지?
2. 핸들과 포인터를 통한 데이터의 간접 접근이 가능한지?
3. 부수 효과를 가져오는 코드가 있는지?

⇒ 한 자원의 생성, 사용, 소멸이 동일한 스레드 내에서 이루어지고, 해당 스레드에서 절대 벗어나지 않는다면 `Thread-safe` 하다고 할 수 있음

### 스레드 안전을 지키기 위한 5가지 방법
1. **Mutual Exclusion (상호 배제)**
    1. 일반적으로 많이 사용하는 방법
    2. **공유 자원에 하나의 Thread만 접근할 수 있도록** 세마포어(Semaphore) / 뮤텍스(Mutex)로 Lock을 통제하는 방법
        1. Semaphore
            - 유지할 수 있는 값의 범위에 따라 이진 세마포어, 카운팅 세마포어로 구분됨
            - 세마포어는 큐에 프로세스(또는 스레드)가 여러 개 있을 때 **강성 세마포어**와 **약성 세마포어**에 따라서 어떤 프로세스를 깨울지가 결정됨 큐에서 선입선출(FIFO)로 깨운다면 강성 세마포어이며, 순서를 특별히 명시하지 않는다면 약성 세마포어이다.
        2. Mutex
            - 이진 세마포어와 같이 0과 1의 초기값을 가짐
            - 프로세스/스레드가 임계영역에 들어갈 때 Lock을 걸어 다른 프로세스/스레드가 접근하지 못하게 하며, 임계영역에서 나와 Unlock을 진행 (Lock을 획득한 프로세스가 반드시 해당 Lock을 Unlock 해야 함)
2. **Atomic Operation (원자 연산)**
    1. 공유 자원 변경에 필요한 연산을 원자적으로 분리한 뒤, 실제로 데이터의 변경이 이루어지는 시점에 Lock → **데이터를 변경하는 시간 동안 다른 스레드의 접근이 불가능하도록 함**
    2. 원자적 연산 : 더 이상 쪼갤 수 없고, 중간에 다른 스레드가 개입할 수 없는 연산
        1. 스레드가 동시에 같은 자원을 수정할 때 발생하는 Race Condition(경쟁 상태)를 방지함
        2. 예시 (java.util.concurrent.atomic - AtomicInteger)
        ```java
        AtomicInteger atomicInt = new AtomicInteger(0);
        
        // 원자적으로 값을 1 증가시킴
        atomicInt.incrementAndGet();
        ```
        iii. 예시 (+=) ”+=” 은 ‘+’ 연산 후’=’ 연산을 하기 때문에 원자적이지 않음
    - [ ] AtomicInteger, CAS 에 대해서 더 알아보면 좋을 것 같음
3. **Thread-Local Storage (스레드 지역 저장소)**
    1. **공유 자원의 사용을 최대한 줄이고 각각의 스레드에서만 접근 가능한 저장소들을 사용함**으로써 동시 접근 방지 (로컬 변수 활용)
    2. 스레드끼리 공유하는 Heap, Data 영역의 자원 접근을 최소화하고 각 스레드가 독립적으로 가지는 스택 영역의 자원만 사용하도록 설계하라 ..
4. **Re-Entrancy (재진입성)**
    1. 함수 A가 스레드 1번에 의해 호출되어 실행 중일 때, 스레드 2번이 함수 A를 호출하더라도 그 결과가 각각에게 올바르게 주어져야 함
    2. 스레드끼리 독립적으로 동작할 수 있도록 코드를 작성하는 것
5. **Immutable Object (불변 객체)**
    1. 불변 객체는 변하지 않는 읽기 전용 자원이므로 여러 스레드가 동시에 접근해도 스레드 안전성이 보장됨
    2. 클래스 자체를 final로 선언, Wrapper 클래스, BigInteger/BigDecimal, 열거 타입 등
    - [ ] 항상 옳은 방법은 아닐 것 같음 찾아보기
---

- [ ] Thread Safe 함을 측정할 수 있는 알고리즘? 테스트 코드? - 주소값
Thread-Unsafe 할 때 어떤 상황이 발생하는가?
