# HTTP 자격증명 헤더
> **한 줄 정리**
> 클라이언트와 서버의 통신이 이루어지기 전에 인증과정으로 사용자의 자격(권한)을 확인할 때 사용되는 헤더

# WWW-Authenticate 헤더
> **한 줄 정리**
> ==서버 → 클라이언트==, `401 Unauthorized` 응답 코드를 가지고 응답하며 최소한 한 번의 시도에 포함된 `WWW-Authenticate` 응답 헤더로 권한을 부여하는 방법에 대한 정보를 제공

# Authorization 헤더
> **한 줄 정리**
> ==클라이언트 → 서버==, `WWW-Authenticate` 헤더로 응답받은 인증 방식에 따라 인증 정보를 `Authorization` 헤더에 포함하여 전송

# Bearer Token
> **한 줄 정리**
> 주로 JWT나 OAuth 2.0과 같이 토큰 기반 인증 시스템에서 사용되며, 해당 토큰의 정보에 기반하여 인증/인가 과정을 진행함

# JWT
애플리케이션 간의 정보 교환을 위해 설게된, 정보를 JSON 형식을 포함하는 자체 포함형 토큰
토큰 자체로 모든 정보를 갖고 있음, 별도의 인증 서버 등에 의존하지 않고 독립적으로 활용 가능

## 사용 이유

### 세션 인증 / jwt 인증 차이
각 사용자마다 세션 데이터를 저장하고 관리, 사용자가 증가할수록 메모리 사용량 증가
서버가 여러 대로 확장될 경우, 세션이 불일치 해짐
매번 부하가 달라짐에 따라서 다른 서버에 요청이 들어가면서 세션 동기화 등.. 세션 클러스터링 등에 의해 리소스 소비

- 무상태 인증
	- 토큰 자체에 사용자 인증 정보 및 데이터를 가져서 세션 상태를 따로 저장하거나 유지할 필요 없음
- 서버 간 부담 감소
	- 세션 저장소를 별도로 구축하는 오버헤드를 줄일 수 있음
	- 시크릿 키를 잘 관리
- 안정적인 확장성
	- 무상태로 동작하기 때문에 로드밸런서를 통해 배치하여 안정성있게 유지 가능
- 보안과 데이터 무결성 보장
	- JWT가 갖고 있는 서명을 통해 위변조를 검증
	- 특정 알고리즘이나 공개키/개인키 등과 관련된 알고리즘을 사용하기도 함
	- 비대칭키~
	- 서명은 토큰의 위변조를 확인
	- 페이로드를 암호화할 수 있음


## 동작 방식
### 토큰 발급 (Token Issuance)
1. 사용자 인증 (아이디, 비밀번호)
	1. 서버가 클라이언트로부터 전달받은 인증정보 (아이디, 비밀번호 등)를 검증
		1. DB, 혹은 소셜로그인 API 등
2. Payload 생성
	1. JSON 형식 데이터
	2. Claim
		1. 필수 클레임 : 토큰 유효성 검증 및 관리
		   - 토큰 발급자, 토큰 제목, 토큰 대상, 만료 시간, 활성 시간, 발급 시간
		2. 비공개 클레임 : 토큰 발급자와 수신자만 알고 있는 클레임 (이름 자유롭게 정의 가능, ex. 사용자 아이디, 이름 권한 정보 등)
		3. 공개 클레임 : 자유롭게 정의할 수 있는 클레임
3. Header 생성
	1. JSON 형식의 데이터
	2. 토큰 유형 : JWT
	3. 서명 알고리즘 : ==HS256==, HMAC, SHA256
4. Signature 생성
	1. Header와 Payload 기반으로 Base64 인코딩 후 비밀키로 암호화하여 생성
5. JWT 발급
	1. Access Token, Refresh Token 
 
### 토큰 전송 (Token Transmission)
클라이언트는 서버로부터 발급받은 JWT를 안전하게 저장하고 보호된 리소스에 접근할 때마다 서버에 전송

1. Authorization Header : Bearer 스키마 (표준 방식, RESTful로 봄)
	- 장점 : 표준 방식, RESTful, 서버에서 쉽게 추출하고 검증할 수 있음
	- 단점 : CORS 문제가 발생할 수 있음
2. Cookie
	- 장점 : CORS 문제가 발생하지 않음, XSS 공격 방어에도 유리함 
	- 단점 : CSRF 공격 방어에 취약하다 -> CSRF Token을 따로 사용하여 구현해야함 (불편)

### 토큰 검증 (Token Verification)
서버가 클라이언트로부터 JWT를 받으면 유효한 토큰인지 검증
1. JWT 추출
	- Authorization Header, Cookie에서 추출
2. JWT 파싱
	- Base64로 디코딩해서 Header, Payload, Signature를 분리
3. 서명 검증
	- Header에 명시된 alg와 비밀키를 사용해서 서명을 검증
	- 클라이언트 서명과 서버 서명을 비교하여 토큰 위변조 여부 확인
4. 클레임 검증
	- 만료 시간, 토큰 발급자, 토큰 대상 등 유효성 검증에 필요한 요소들에 대해 검사
5. 인증 성공 / 실패

### 권한에 따른 처리 (Authorization based on Token)
서버는 JWT Payload에 포함된 사용자 정보, 권한을 통해서 인가 처리

- [ ] 인가 처리
	- **Role-Based Access Control (RBAC)**
		- 역할 기반 접근 제어 방식
			- ex. `role: "admin"`
		- Payload의 사용자 역할 정보를 기반으로 인가 처리
	- **Attribute-Based Access Control (ABAC)**
		- 속성 기반 접근 제어 방식
			- ex. `age, group, department` 등
		- 사용자 속성 정보를 조합하여 동적으로 접근 권한
		- RBAC 보다 세밀하고 유연하게 접근 제어 가능


## JWT와 세션 혼합 구현 방식
JWT의 단점을 보완, 세션의 장점을 활용

### 구현 방식
- JWT가 탈취되어도, 세션 무효화로 제어 가능
- 서버에서 세션 정보를 저장할 수 있기 때문에 필요에 따라 조정/확장 가능
- 서버 리소스를 보다 효율적으로 사용 가능

## JWT 취약점 및 해결책

- HttpOnly 쿠키 사용
- 민감한 정보는 포함하지 않을 것
- Refresh token으로 탈취에 대한 예방
- Refresh token을 더 안전한 저장소에 두어 보안성 강화

> [!note] #정리필요 
> - [ ] 세션 기반 인증, JWT 기반 인증 장단점
> - [ ] 인가 처리 관련 상세 내용
> - [ ] 어디에 저장/전송하는 게 좋을지? (로컬, 세션 스토리지에는 JWT에는 저장 금지)
> - [ ] JWT 방식, 세션 방식 개별적으로 이해하기

---
# OAuth
인터넷 사용자들이 애플리케이션 간에 인증과 권한 부여를 안전하게 공유할 수 있도록 설계된 **오픈 표준 프로토콜**

## 사용 이유
- ==사용자의 비밀번호를 노출하지 않고==, 안전하게 접근하도록 할 수 있음
- 비밀번호가 직접 공유되면 노출될 가능성도 있기 때문에 안전함
- 제한적인 접근 권한만 안전하게 제공 가능

## 동작 방식

![[Pasted image 20250213130400.png]]
### 구성 요소
- Resource Owner : 사용자
- Client : 정보 요청하는 어플리케이션 (사이트 자체)
- Authorization Server : 인증 정보를 발급해주는 서버
- Resource Server : 실제로 사용자 정보를 갖고 있는 서버 (함부로 접근 불가능)

### 동작 순서
- 2) 소셜 로그인을 하는 곳에 요청
- 5) 로그인 성공 시 임시 티켓 발급, 인증 코드와 화면에 대한 정보를 클라이언트에게 전달
- 7) 인증 코드(임시 티켓)과 사용자 정보를 이용하여 Access Token 요청
- 8) 해당 정보가 유효할 경우, Access Token을 클라이언트에게 제공
- 9) 클라이언트가 사용자에게 로그인 성공을 던짐
- 10) Access Token을 활용하여 서비스를 요청
- 12) Access Token의 유효성을 요청이 들어올 때마다 검증함

> [!quote]
> *RFC*
> 인터넷 기술에 관한 법전과 같은 존재, 기술의 표준이 됨
