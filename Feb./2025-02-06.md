# 동시성, 스케줄러, 병렬성

## 동시성
> **한 줄 정리**   
> 하나의 CPU를 사용하여 빠른 작업 처리로 동시에 보이는 것처럼 하는 것

굉장히 빠르게 여러 개의 작업을 처리함 
→ 우리의 눈에는 동시에 처리하는 것’처럼’ 보이는 것 (약간의 속임수와도 같음)

환경에 따라 병렬성보다 동시성이 더 효율적인 부분이 있으니, 잘 고려하여 사용할 필요가 있음

### 주요 특징

- 작업 간 전환 → 스케줄러가 진행
    - 여러 작업을 **빠르게 전환**하며 실행, 실제로 병렬 실행은 아님
    - 눈 깜짝할 사이에 빠르게 왔다갔다 함
    - 컨텍스트 스위칭과 연관
- 자원 공유
    - cpu와 메모리를 최대한 쥐어짜내서 활용하는 것
- 운영체제의 역할
    - **스케줄링**을 통한 멀티태스킹 구현
    - 운영체제 안에 스케줄러가 있음 (ex. 오케스트라의 지휘자 같은 역할)
    - 스케줄러가 있어서 여러가지 시스템을 사용할 수 있음
- 적용 분야
    - I/O 중심 작업, CPU를 효율적으로 사용하기 위한 (놀고 있는 시간을 최소화)

### 알아야하는 이유

백엔드 서버, 유지보수

- 여러 사용자의 접속에 대한 대응
- 불필요한 서버 자원이 나가지 않도록 하는 것도 중요..
- 동시성이 설계에 잘 되지 않으면 유지보수에서도 어려움
- 게임 개발에 필수!
    - 동시성 기술이 모자라면 게임이 잘 돌아가지 않을 수도 있음
    - 딥한 레벨에서부터 개발하는 게 많음, 라이브러리나 프레임워크도 다 입맛에 맞춰서 다시 뜯어고치기도 함

### 동작 방식

- 스케줄러는 cpu가 어떤 작업을 얼마나 오래 할지 등을 정함
    - 여러 개의 서버 인스턴스가 존재했을 때, 한 쪽에만 부하가 걸리지 않도록 나눠주는 역할

1. 작업 분할
	1. 작업을 왔다갔다 할 때 이전의 작업에 대한 기억을 해둬야 함 (컨텍스트 스위칭) 책갈피 같은 역할
    1. 저장을 하고 다시 쓰는 것에서 리소스가 들어감 → 이런 과정 자체가 오버헤드 될 수 있음
    2. 메모리에 저장하고 메모리에 접근해야 함
3. 시간 할당
    3. 각 작업에 대한 짧은 실행 시간을 할당하여 순차적으로 실행
4. 컨텍스트 스위칭
    4. 작업 간 전환 시 필요한 상태를 저장 및 복원
    5. 컨텍스트 스위칭이 많이 일어날수록 리소스 자원이 많이 사용됨
        1. 따라서 컨텍스트 스위칭을 가장 효율적으로 최소화 시켜야 한다. → 동시성 관리에서 중요한 맥락

### Thread Pool
> 미리 일정 개수의 스레드를 생성하여 관리하는 기법

```
생성된 스레드들은 작업을 할당받기 위해 대기 상태에 존재
→ 작업이 발생하면 대기 중인 스레드 중 하나를 선택하여 작업 수행
→ 작업 완료 후 해당 스레드는 다시 대기 상태로 복귀 + 새로운 작업을 할당받을 준비

(재직 당시 막내라 프로젝트 오픈하고 대기조로 기다렸던 게 생각난다...)
스레드풀 = 대기조 느낌으로 이해하면 될 듯?
```
#### 장점
- 자원 효율성
	- 미리 정해진 개수의 스레드를 생성하여 관리하기 때문에 스레드 생성 및 삭제에 따른 오버헤드를 줄일 수 있음
	- 시스템의 자원을 효율적으로 관리할 수 있고, 불필요한 자원 소모를 방지함
- 응답성 및 처리성 향상
	- 작업을 대기 상태로 유지하여 작업 처리 속도를 향상시킬 수 있음
	- 작업 발생 → 대기 상태의 스레드 중 하나 선택 → 작업 할당
	  => 작업 처리 병렬 진행 가능
- 작업 제어
	- 동시에 처리할 수 있는 작업의 개수를 제한할 수 있음
	- 스레드 풀의 크기를 조절하여 시스템의 부하를 조절, 과도한 작업 요청으로 인한 성능 저하 방지
- 스레드 관리
	- 스레드의 생명 주기를 관리할 수 있음
	- 스레드의 생성, 재사용, 종료 등을 관리하므로 스레드의 안전한 운영을 도와줌

---

# 스케줄러
> **한 줄 정리**   
**운영체제의 핵심 구성요소**이자, **시스템 자원 분배** 및 프로세스나 스레드의 **실행 순서를 관리**하는 역할 (교통 경찰)


### 주요 기능
- 작업 선택
    - 어떤 작업을 실행할지결정
    - 계속해서 다음에 누굴 실행할지 고민함 (긴급하거나, 우선순위가높은 것부터 실행)
- 자원 분배
    - 제한된 자원을 여러 작업이 공평하게 사용할 수 있도록 분배함
- 컨텍스트 스위칭 관리
    - 중단 없이 진행되도록 함, 이전 작업의 상태를 기억해야 한다
### 종류
1. 장기 스케줄러 (Job Scheduler) : 메모리와 디스크 사이를 담당하는 스케줄러
	1. 시스템에 얼마나 많은 작업을 실행할지 결정
	2. 어떤 프로세스를 Ready Queue에 넣을 것인가?
2. 중기 스케줄러 (Swapper) : 메모리에서 CPU를 점유하기 위해 경쟁하는 프로세스를 디스크로 보내는 스케줄러
	1. 메모리에 있는 작업 중 어떤 작업을 임시로 중단할지 결정 (메모리 관리자) 
	2. 메모리가 부족해지면 비교적 중요하지 않은 작업을 디스크로 이동(Swap Out)
	3. 다중 프로그래밍의 정도를 완화
3. 단기 스케줄러 (CPU Scheduler) : CPU와 메모리 사이를 담당하는 스케줄러
	1. 실행 준비가 완료되어 Ready Queue에 있는(메모리에 존재하는) 프로세스들 중에서 선택하여 CPU를 할당
	2. 단기 스케줄러는 자주 수행되므로 빨라야 함

### Queue 종류
1. 작업 큐 (Job Queue) : 시스템 안의 모든 프로세스들로 구성
2. 준비 큐 (Ready Queue) : 메인 메모리에 존재, 준비 완료 상태에서 실행을 대기하고 있는 프로세스들로 구성
3. 장치 대기 큐(Device Queue) : 특정 입/출력장치를 대기하는 프로세스들의 리스트로 구성
### 사용 이유
- 시스템 성능 최적화
    - CPU 사용률을 최대한 끌어올리며 작업량을 증가
    - 총 처리 시간의 감소
    - 작업의 대기시간 감소

→ 이로써 사용자 경험을 개선할 수 있음

### 사용 방법
1. 작업 대기열 관리
    1. 대기 중인 작업을 대기열(큐)에 배치 → 선입선출 방식
2. 우선순위 설정
    2. 대기열에 있는 작업들에 대해 우선순위를 결정
    3. 종류, 긴급성 등에 따라 결정
3. 자원 분배
    4. 각 작업에 필요한 CPU, 메모리 등 자원 할당
4. 작업 전환
    5. 컨텍스트 스위칭을 수행 → 빠르고 효율적으로 움직여야 함
5. 완료 및 자원 해제
    6. 작업 완료 후 작업을 해제 및 회수 등으로 불필요한 자원이 할당되지 않도록 해야 함

---

# 병렬성

여러 CPU 코어, 물리적으로 동시에 실행

### 주요 특징

- 하드웨어 의존적
    - 병렬 처리기 때문에 CPU가 많을 수록, 하드웨어가 많을 수록 하드웨어(엔진) 자체가 많을 수록 좋음
- 작업의 독립성
    - 각 작업을 격리된 공간에서 독립적으로 실행
    - [ ] 완전 독립되어있지만 협력도 가능함 ?!
- 계산 중심
    - 대규모 데이터 처리, 연산 중심 … 병렬적으로 동시에 할 수 있는 것에 대해 특화되어 있음
- **성능 향상**
    - 코어 수가 많을 수록 더 많은 작업을 (더 빠르게) 동시에 처리 가능

### 알아야하는 이유
면접에 자주 등장
- 실시간 스트리밍, 온라인 게임, 자율주행 , 빅데이터 분석, 인공지능 학습 등 모두 병렬성 사용
- 특히 영상처리/스트리밍 등등
### 동작 방식
1. 작업 분할
    1. 실행할 작업을 독립적인 작은 단위로 나눔
    2. 일을 잘게 쪼갤수록 작업 처리 효율이 높아짐
2. 자원 할당
    1. 각 작업에 대해 사용 가능한 CPU 코어, 메모리 등 하드웨어 자원 할당
    2. 나눠진 작업들을 각각의 CPU 코어에 할당
    3. 할당을 효율적으로 해야 병렬 처리 성능을 최대로 끌어올릴 수 있음
3. 병렬 실행
    4. 자원이 할당된 작업들은 각자의 자리에서 동시에 실행
4. 결과 통합
    5. 병렬적으로 처리된 작업들을 하나로 합쳐서 유저에게 서빙
5. 오류 및 복구 관리
    6. 병렬 처리 중 네트워크, 하드웨어 고장 등의 이유로 작업이 중단될 수 있기 때문에 중단 없이 실행될 수 있도록 복구

#### 예시
수 천 장의 이미지를 한 번에 로딩하려는 상황 (병렬성)
1. 대용량 이미지를 받아와서 젖체 이미지를 작은 이미지 블록 (작업분할)
2. 이미지 처리할 CPU 코어 할당 (자원 할당)
3. 실질적인 실행 , 이미지 블록 나눠져 있는걸 CPU가 동시에 실행 (병렬 실행)
4. 이미지 블록들 나눈 걸 다시 합쳐서 결과물로 전송 (결과 통합)
5. 오류 및 복구, 이미지 처리 시 발생했던 부분이 있다면 해당 블록만 재처리 (오류 및 복구 관리)

### 이점
- 실시간 시스템, 사용자 응답성 개선
- 대규모 작업 시간 절약
- 자원 활용 극대화

→ 시스템으로서의 경쟁력을 높일 수 있는 부분

# 동시성/병렬성 관계
- [x] 따로 정리 진행
- 본질적으로 다른 개념이지만, 서로 상호보완적인 관계를 가지고 있음을 인지하기
- 동시성은 논리적인 개념, 병렬성은 물리적인 개념으로 둘은 공존할 수 있음
	- 병렬성으로 작업하며 동시성을 가져갈 수 있음
- 동시성은 병렬성이기 위한 필요조건이지만 충분조건은 아니다..
	- 병렬성을 만족하면 동시성도 만족함 → 병렬성은 동시에 실행되기 때문
	- 동시성을 만족한다고 병렬성을 만족하진 않음 → 두 개가 동시에 처리되는 것처럼 보인다 해도 실제로 동시에 처리되는지는 알 수 없기 때문

*사실 대부분의 시스템에서 동시성과 병렬성을 함께 사용함, 상황에 따라 적절히 사용할 것*

---
오늘 배웠던 내용은 대체적으로 이해하기 수월했다.   
시스템에서의 동작 방식이 아니고 이론적으로 이해하면 되는 부분이라 그런 것 같다.   
TIL 이라는 걸 항상 생각해봤었는데, 막상 잘 도전하지 못 했던 이유는 깔끔하게 정리해야한다는 강박 때문이었던 것 같다.
   
사실 정리라는 게.. 내 머릿 속에 개념이 잘 잡히는 게 먼저기 때문에 그럴 필요가 없는데   
정리를 하다보니 자꾸 욕심이 생겨서 이것저것 찾아보다가 시간을 쓰기도 하고 그러는 것 같다.   

그래도 수업을 들으면서, 정리를 하면서 간만에 공부의 재미를 느꼈던 순간 같아서 마냥 아까운 시간은 아니었던 것 같다.   
하지만 너무 반복적이진 않게 적당히! 찾아보면서 정리를 해나가야 겠다.   
하다보면 정리는 쉬워질테니까~

