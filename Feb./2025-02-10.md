# 공유 자원
> **한 줄 정리**
> 여러 사용자나 스레드/프로세스가 동시에 접근하거나 사용할 수 있는 시스템 내의 자원

# 임계 영역
> **한 줄 정리**
> 공유 자원에 접근하는 프로그램 코드의 일부분, 동시에 여러 스레드/프로스가 접근하면 문제가 생길 수 있는 구간

# 동기화
> **한 줄 정리**
> 스레드/프로세스 등이 공유 자원에 동시에 접근할 때 발생할 수 있는 충돌이나 데이터 무결성 문제를 방지하고, 데이터를 안전하게 읽고 쓸 수 있도록 제어하는 과정

### 상호배제(Mutual Exclusion)
> **한 줄 정리**
> 하나의 프로세스가 임계 영역에서 실행 중일 때, 다른 프로세스는 임계 영역에 들어갈 수 없음
> *임계 영역에는 반드시 하나의 프로세스만 진입하도록 보장함*

### 진행(Progress)
> **한 줄 정리**
> 공유 자원에 접근 중인 프로세스가 없고 대기 중인 프로세스들만 있을 경우, 대기 중인 프로세스 중 하나는 반드시 임계 영역에 들어가 실행되어야 함
> *경쟁 프로세스가 없을 때, 즉시 실행이 가능해야 함*

### 유한한 대기(Bounded Wating)
> **한 줄 정리**
> 접근하려는 임계 영역이 다른 스레드/프로세스에 의해 점유되어 있을 경우, 임계 영역의 대기가 유한해야 함 (무한히 기다리지 않고, 언젠가는 실행 기회를 보장받아야 함)
> *대기 중인 프로세스가 영구적으로 차단되지 않도록 함*

# 락
> **한 줄 정리**
> 하나의 스레드/프로세스가 자원을 점유하고 있을 경우, 다른 스레드/프로세스가 해당 자원에 접근지 못하게 하여 공유 자원의 데이터 무결성을 보장하기 위한 동시성 제어 기법

## 알아야하는 이유
- 데이터 무결성 손실, 데이터 경합, 데드락과 같은 문제를 방지할 수 있는 동기화의 핵심 메커니즘
- 공유 자원의 데이터 무결성을 보호
- 중단 없이 완료되거나 아무것도 수행되지 않은 상태로 남도록 보장함 (원자성)
	- 원자성을 통해 작업 단위가 안전하게 수행되도록 보장함 → 데이터의 안정성과 일관성 유지

# 원자성
> **한 줄 정리**
> 더 작게 쪼개질 수 없는 단위이며 하나의 원자적 실행 단위로 동작함을 보장하는 개념


# 데드락
> **한 줄 정리**
> 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한한 대기에 빠지는 상황

### 발생 조건
- 상호 배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있음
- 점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 함
- 비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없음
- 순환 대기 : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 함

# Race Condition
> **한 줄 정리**
> 둘 이상의 프로세스가 동시에 공유 자원에 접근했을 때, 올바른 제어를 하지 않아 데이터의 무결성이 보장되지 않아 예기치 않은 결과가 발생하는 상황

(선택) 기아 현상

(선택) 락-프리 (Lock-Free) / 웨이트-프리 (Wait-Free) 알고리즘

# 스핀락
> **한 줄 정리**
> 한 스레드가 임계 영역을 점유하고 있을 때, 다른 Thread가 락이 해제되기를 기다리며 계속해서 락 상태를 확인하는 방식

### 동작 방식
1. 임계 구역에 여러 스레드가 동시에 접근함
2. 먼저 요청된 스레드에 대해 접근을 허용
3. 다른 스레드는 락이 해제되었는지 계속 반복적으로 확인 (busy-wating)

# 낙관적 락
> **한 줄 정리**
> 트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법으로, 여러 트랜잭션이 동시에 데이터에 접근할 수 있도록 허용해 줌

### 동작 방식
1. 특정 트랜잭션이 데이터를 read
2. 수정이 발생할 때 해당 데이터의 버전을 +1로 update
3. 다른 트랜잭션이 동일한 데이터에 대해 수정 요청
4. 이 때 버전이 다르기 때문에 데이터 수정에 실패 및 예외 처리 (갱신 손실 문제를 예방)
** 단, 트랜잭션 커밋 시 버전 정보가 달라 발생하는 예외에 대한 예외처리를 해주고, 예외가 발생했던 로직을 재시도하도록 해야 함

# 비관적 락
> **한 줄 정리**
> 데이터를 요청할 때 동시성 문제가 발생할 것이라는 전제 하에 락을 거는 방법으로, 데이터를 수정하기 전에 해당 데이터에 대한 접근을 미리 제한하는 방식

### 동작 방식
1. 첫 번째 트랜잭션이 데이터를 read 후 배타락을 걸어둠
2. 두 번째 트랜잭션이 데이터를 read 하려 했으나, 배타락으로 인해 조회 불가
3. 두 번째 트랜잭션은 첫 번째 트랜잭션의 배타락이 해제될 때까지 대기
4. 첫 번째 트랜잭션이 데이터 수정을 완료하고 커밋
5. 두 번째 트랜잭션이 데이터에 접근 후 read 시 배타락을 걸어둠
6. 두 번째 트랜잭션이 데이터를 수정하고 커밋 진행

# 뮤텍스
> **한 줄 정리**
> **Mut**ual **Ex**clusion의 단어를 따와서 생긴 말, 
> 한 번에 하나의 스레드만 자원에 접근할 수 있도록 제한하며 Lock의 소유권과 해제 권한을 특정 스레드에 부여함

### 동작 방식
1. 스레드 1이 공유 자원에 접근하기 위해 락 요청 및 점유
2. 스레드 2가 공유 자원에 접근을 시도했으나 락이 이미 점유되어 뮤텍스 대기 큐(FIFO)에 진입하여 대기 상태로 전환
3. 스레드 1이 작업 완료 후 락 해제 및 공유 자원이 비활성 상태로 전환


# 조건 변수(Condition Variable)
> **한 줄 정리**
> 특정 스레드가 작업을 수행하기 위한 조건을 부여하여 순서 관계를 보장함
> (기본적으로 Mutex를 내포하고 있음)

# Read-Write Lock
> **한 줄 정리**
> Read Lock이 걸린 상태에서 다른 Read Lock이 걸려오면 Read 작업을 그대로 수행하도록 하고, Write Lock일 경우 Block 시킴
- Mutex 방식과 비교해보았을 때, Mutex는 Read/Wirte 구분 없이 배타적인 사용방식을 고수한 것과 달리 Read-Write Lock은 Read의 경우 내용의 일관성을 해치지 않기 때문에 동시에 Read로써 접근하여도 동기화 문제가 발생하지 않음을 이용하여 보다 자원을 효율적으로 이용할 수 있도록 함
- 그러나 Read 작업이라고 전부 다 수행해버리면 Write 작업의 순위가 한참 밀릴 수도 있기 때문에 Write 작업이 먼저 대기하고 있다면 Read 작업도 대기하도록 함

# 세마포어
> **한 줄 정리**
> 사용하고 있는 스레프/프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성
