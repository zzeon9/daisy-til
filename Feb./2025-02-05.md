## 동기 / 비동기

✅ 구분 : 순서대로 해야하는지, 독립적으로 해야하는지

- 동기 : **직렬적인 태스크 수행 방식,** 함수 호출 시 해당 작업의 결과가 반환될 때까지 꼼짝없이 기다림
    - 반드시 순서대로 진행해야 하며, 이전 작업이 완전히 끝나야 다음 단계로 넘어갈 수 있음(ex. 계주에서의 바톤터치)
    - 전체 작업 흐름이 한 작업의 완료를 기다리며 진행
- 비동기 : **병렬적인 태스크 수행 방식,** 함수 호출 시 반환되는 동안 다른 작업을 할 수 있음
    - 서로의 작업 완료를 기다리지 않고 독립적으로 진행
    - 준비된 이전 작업의 완성물이 있다면 진행, 없다면 이전 작업이 준비될 때까지 쉬거나 다른 작업 진행 가능
    - 각자의 작업 완료 시점에 서로에게 알림을 줄 수 있음

## 블로킹 / 논블로킹

✅ 구분 : 다른 작업을 차단할 수 있는가/없는가

- 블로킹 : 다른 작업을 막는다
    - 작업 처리의 흐름이 중단됨
    - A에서 B를 호출할 경우, 제어권을 넘겨주었기 때문에 B의 작업이 종료될 때까지 기다려야 함
    - 특정 작업을 실행할 때 제어권을 완전히 넘기는 방식
    - 제어권이 넘어갔기 때문에 아무것도 할 수 없음 (Block)
    - 순차적 실행을 보장하며, 실행 흐름을 쉽게 관리할 수 있음
- 논블로킹 : 다른 작업을 막지 않는다
    - 다른 작업을 기다릴 필요 없이 각자 할 일을 독립적으로 진행
    - 순차적이지 않음
    - 처리 능력 향상, 시스템 자원을 최대한 사용할 수 있으며 사용자 요청에 빠르게 응답 가능
    - 방식
        - 특정 작업을 실행할 때 제어권을 넘겨 실행 후 즉시 돌려 받는 상태
        - 제어권을 바로 돌려받았기 때문에 작업이 진행되는 동안 다른 작업을 진행할 수 있음

## 동기 / 비동기의 차이를 설명하고 파일 읽기 작업을 예시로 들어 설명해주세요

- 동기
    - 작업의 순서가 중요함. 제어권과는 별개로 요청한 작업에 대해 완료 여부를 따져 순차대로 처리함
    - 예시) 파일을 읽어들이는 함수를 호출하는 순간부터 파일 읽기 작업이 온전히 끝날 때까지 기다려야 함 파일을 읽는 과정으로 인해 프로그래스/로딩 바와 같은 애니메이션을 본 거랑 비슷할까?
- 비동기
    - 작업의 순서가 중요하지 않음. 요청한 작업에 대해 완료 여부를 따지지 않기 때문에 자신의 다음 작업을 그대로 수행함
    - 예시) 파일을 읽어들이는 함수를 호출하고 파일 읽기 작업을 하는 동시에 다른 작업을 수행할 수 있음 파일이 다 읽히지 않았지만 상단 메뉴나, 레이아웃 등이 먼저 보여지는 거랑 비슷할까?

## 블로킹과 논블로킹을 제어권 관점에서 설명해주세요.

- 블로킹 : 호출하는 함수에게 제어권을 넘김으로써 작업이 중단되고 해당 함수의 작업이 완료될 때까지 작업을 수행하지 못함
- 논블로킹 : 호출하는 함수에게 제어권을 넘김과 동시에 다시 회수하여 작업을 계속 진행할 수 있고, 해당 함수 또한 작업을 계속 진행할 수 있음

## 동기 / 블로킹과 동기 / 논블로킹 조합의 차이를 설명해주세요.

- 동기 + 블로킹
    - 순차적 실행, 제어권이 다음 작업으로 넘어가면서 다음 작업의 종료에 따라 현재 작업 실행 시점이 달라짐
    - 각 작업의 종료 시점이 곧 다음 작업의 시작 시점이 됨
- 동기 + 논블로킹
    - 제어권을 넘겨주지 않고 자신의 작업을 계속 진행함 (논블로킹)
    - 동기 방식의 작업 흐름 자체가 **다른 작업의 완료를 기다리는 것**이기 때문에 중간중간 완료가 되었는지 확인함

### 동기 / 블로킹 vs 동기 / 논블로킹

상황에 따른 성능 차이는 발생하겠지만, 일반적으로 동기 + 논블로킹이 효율적
이유는 호출 함수가 제어권을 갖고 있어 다른 작업을 병렬적으로 수행할 수 있기 때문

### 동기 / 블로킹 vs 비동기 / 블로킹

개념적 차이가 있을 뿐 성능적 차이는 없음
하지만 비동기 블로킹의 경우 다룰 일이 거의 없음 (안티 패턴)

## 비동기 I/O와 논블로킹 I/O는 같은 개념인가요? 두 개념이 어떻게 다르다고 생각하시나요?

동기/비동기 : 전체적인 작업에 대한 순차적인 흐름 유무
블로킹/논블로킹 : 전체적인 작업의 흐름 자체를 막냐, 안 막냐

- 비동기 I/O
	- 작업의 완료 여부를 따지지 않고, 독립적으로 작업을 진행하는 것이기 때문에 입력된 순서에 따른 출력 순서가 동일함을 보장할 수 없음

- 논블로킹 I/O
	- 작업의 흐름을 막지 않고 제어권을 넘겨주었다가 회수하여 동시에 작업 진행이 가능하도록 함

사실 개념은 다르지만, 실행 관점으로 봤을 때는 큰 차이를 못 느낄 것 같다..
둘 다 성능이나 속도 측면에서는 좋다고 보이지만

> 비동기는 **출력 순서**와 관련된 개념, 논블로킹은 **병렬 실행**과 관련된 개념
> 
> ```
> 그런데 결국은 비동기나 논블로킹이나 추구하는 결과로만 보자면 동시에 다른 작업을 수행한다는 점에서 그게 그것이라고 볼 수도 있다.
> 이는 시점과 관련된 이론적인 개념이라 실제 코드에서 경계를 구분하기가 애매하기도 하다.
> 그래서 프로그래밍에선 이를 혼용하여 사용하는 것 같다. 그러나 엄연한 나타내는 의미는 다르다.
> ```
> 
>  [👩‍💻-동기비동기-블로킹논블로킹-개념-정리#비동기와_논블로킹_개념_차이](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC#%EB%B9%84%EB%8F%99%EA%B8%B0%EC%99%80_%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9_%EA%B0%9C%EB%85%90_%EC%B0%A8%EC%9D%B4)
