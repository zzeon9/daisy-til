## DeepDive

1. 자바의 메모리 영역과 컴파일과정을 서술하시오
    1. 메모리 영역
        - 나의 생각
            Runtime Data Area 영역에 적재, Class Loader가 실시간으로 필요한 바이트 코드를 적재
        - 검색 결과
            - Runtime Data Area
              ![스크린샷 2025-01-24 오전 11 05 42](https://github.com/user-attachments/assets/8d6a5b4c-b4c8-473b-948a-7173e715bba6)
                1. Method Area : JVM이 시작될 때 생성되는 공간, 바이트 코드를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장 
                    1. 모든 스레드가 공유하는 영역, 변수/메소드/유형에 관한 정보 저장
                    2. 클래스가 로드될 때 적재되며 프로그램이 종료될 때까지 저장
                2. Heap Area : JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역
                    1. new 연산자로 생성되는 클래스와 인스턴스 변수, 배열 타입 등 Reference Type이 저장
                    2. heap의 참조 주소는 stack이 갖고 있고 해당 객체를 통해서만 heap 영역의 인스턴스를 핸들링 할 수 있음
                3. Stack Area : 기본 자료형을 생성할 때 저장하는 공간
                    1. 임시적으로 사용되는 변수나 정보들이 저장되는 영역
                    2. 메소드 호출 시 마다 각각의 스택 프레임(그 메소드만을 위한 공간)이 생성, 호출된 메소드의 매개변수/지역변수/리턴 값 및 연산시 일어나는 값들을 임시저장
                    → 메소드 수행이 끝나면 프레임 별로 삭제
                4. PC Register : 스레드가 시작될 때 생성, 현재 수행중인 JVM 명령어 주소를 저장하는 공간
                    1. PC Register와 CPU Register
                        1. Java는 OS나 CPU의 입장에서는 하나의 프로세스에 불과함.
                        그래서 JVM의 리소스를 사용해야 하며, CPU에 직접 연산을 수행하도록 하는 것이 아닌 현재 작업하는 내용을 CPU에게 연산으로 제공해야 함.
                        이를 위한 버퍼 공간으로 PC Register 라는 메모리 영역을 만들게 된 것!
                        따라서 둘은 다르다~
                5. Native Method Stack : 바이너리 코드로 작성된 프로그램을 실행시키는 영역
                    1. 메소드를 실행 → stack에 쌓이다가 해당 메소드 내부에 native 방식을 사용하는 메소드가 있다면 해당 메소드는 native stack에 쌓임
                    2. native method 수행 및 종료 → java stack 작업 재수행
    2. 컴파일 과정
        - 나의 생각
            JVM에서 먼저 기계어로 변환된 바이트 코드를 바이너리 코드로 컴파일 하는 과정을 거침
        - 검색 결과
            1. .java 파일 작성
            2. Java Compiler(javac)가 .java 파일을 컴파일하여 .class 파일(바이트코드) 생성
            3. .class 파일을 JVM의 `Class Loader`에게 전달
            4. `Class Loader`는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크의 과정을 거쳐 `Runtime Data Area`(메모리)에 적재
            5. `Execution Engine`은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행
                1. 인터프리터 
                - 바이트 코드 명령어를 하나씩 읽어서 해석 후 실행
                - 컴파일을 거치지 않지만 전체적인 실행 속도가 느린 단점
                2. JIT 컴파일러
                - 인터프리터의 단점을 보완하기 위해 도입
                - 바이트 코드 전체 컴파일 → 바이너리 코드 변경
                - 전체적인 실행속도는 인터프리팅 방식보다는 빠르지만, 한 번만 실행하면 되는 코드는 인터프리팅하는 것이 더 유리함
2. 가비지 컬렉션(Garbage Collection)에 대해 정의하고 어떻게 동작하는지 서술하시오
    1. Java 외에 다른 언어 한가지를 정하고 어떻게 Garbage Collection이 동작하는지 서술하고 비교해보세요.
        - 나의 생각
            음.. C언어 예시를 들고 설명하고 싶은데 C에서 GC가 어떻게 동작하는지를 모른다… 찾아봐야겠다
        - 검색 결과
            C#
            1. 스택 메모리의 경우 함수의 실행~종료까지 알아서 줄어들고 늘어나기 때문에 신경 쓸 필요는 없음.
            2. 하지만 힙의 경우 메모리를 할당한 뒤 어떤 행동도 하지 않으면 계속 메모리에 올라온 상태로 유지되기 때문에 C/C++ 개발자가 메모리를 직접 코드 상으로 관리해주어야 함
            C#은 CLR이 자동적으로 메모리 관리를 해줌
                1. CLR이란? 
                `Common Language Runtime`, .NET Framework의 VM이며 JAVA의 JVM과 비슷한 역할
    2. Java GC도 여러 종류가 있습니다. 어떤 차이점이 있는지 간단하게 서술하시오.
        - 검색 결과
            1. Serial GC : 스레드가 1개, stop-the-world 시간이 가장 길다
            2. Parallel GC : Serial GC와 기본적인 알고리즘은 동일, Young 영역의 Minor GC를 멀티 스레드로 수행 → Serial GC에 비해 stop-the-world 시간 감소
            3. Parallel Old GC : Parallel GC 개선 버전, Old 영역까지 멀티 스레드 수행
            4. CMS GC : 어플리케이션 스레드와 GC 스레드가 동시 실행, stop-the-world 시간을 줄이기 위해 고안되었으나 GC 과정이 매우 복잡하고 메모리 파편화 문제 등으로 인해 결국 Java 14 부터는 사용 중지
            5. G1 GC(Java 9+) : CMS GC 대체를 위해 탄생, 기존의 Young/Old 영역의 개념을 뒤엎고 Region이라는 개념을 새로 도입 → **역할 동적 할당**
            6. Shenandoah GC(Java 12) : CMS의 단편화, G1이 가진 pause의 이슈 해결
            7. ZGC(Java 15) : 최대 장점 중 하나는 힙 크기가 증가하더라도 s**top-the-world의 시간이 절대 10ms를 넘지 않는다는 것**
3. Java에서 예외에 대해 서술하시오
    1. 예외 처리의 목적
        - 나의 생각
            사용자의 편의를 위해? 프로그램의 갑작스런 오류로 인해 불편을 겪지 않도록 하기 위해?
        - 검색 결과
            예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상적인 동작을 막고, 에러를 잡아 복구를 시도하거나 회피 하는 식으로 처리해서 프로그램이 정상적인 실행상태를 유지할 수 있도록 함
    2. 예외 처리의 의미
        - 나의 생각
            발생할 수 있는 예외에 대해 기존 방식이 아니라 사용자 편의에 가까운 대처 방식을 제공하기 위해?
        - 검색 결과
            프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것
    3. 오류와 예외의 차이점
        - 나의 생각
            오류 : 문법적 혹은 논리적으로 잘못된 개발 방향
            예외 : 경우에 따라 발생 조건이 달라지는 것?
        - 검색 결과
            오류 : 시스템이 종료되어야 할 수준과 같이 수습할 수 없는 심각한 문제, 개발자가 미리 예측하여 방지할 수 없음
            예외 : 개발자가 구현한 로직에서 발생한 실수나 사용자의 영향에 의해 발생
    4. 확인된 예외와 확인되지 않은 예외의 차이점
        - 나의 생각
            확인된 예외 : 대부분 발생할 확률이 높다?
            확인되지 않은 예외 : 발생하지 않을 확률이 높아서 개발 기간동안에 발견할 확률이 적어 운영에서 문제를 일으킬 확률이 높다?
        - 검색 결과
            확인된 예외(CheckedException) : 모두 Exception을 상속받음
            미확인 예외(UncheckedException) : 모두 RuntimeException을 상속받음 (RuntimeException을 상속받지만 자바에서는 특별 취급 받음)
            + 예외 발생 시점은 둘 다 **런타임 시점** (가끔 혼동되는 경우가 있음, 중요)
            → 확인된 예외(CheckedException)의 경우 컴파일러가 예외처리를 확인 하는 과정에서 코드가 실행되지 않기 때문에 컴파일 환경에서 발생하는 것으로 보임.
