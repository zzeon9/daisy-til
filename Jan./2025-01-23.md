## JDK와 JRE
- JRE : 자바 실행을 위한 환경
- JDK : 자바 개발을 위한 도구
	- Debugger : 디버깅 도구
	- JavaDoc : 자바용 문서를 생성
	- 버전별 차이를 알아도 좋음

## JVM
> Bytecode를 JVM으로 가져온 후 Runtime Area에 배치해서 Execution Engine으로 실행

### Class Loader
> 필요한 바이트코드만 실시간으로 런타임에 적재
> 콘솔 로그에 직접 찍어볼 수도 있음

1. 로딩
    1. 필요한 바이트 코드 찾아 메모리에 로드
2. 링크
    2. 로딩된 바이트코드를 jvm에서 적절한지 여부를 확인하여 준비
    3. 검증, 준비, 해석(분석)
        1. 준비 과정에서 런타임 데이터 영역에 적재되는지? 찾아보면 좋음
3. 초기화
    1. 클래스 및 정적 코드 블록 실행

### Runtime Data Area
> 프로그램을 실행하기 위해 사용하는 메모리 영역
> OS 위에 JVM을 띄우고, JVM 위에 프로그램을 돌려야 하는 메모리가 존재한다고 생각하면 됨

(내용 보완 예정)
- Stack
	- 임시 데이터 관리
- Native Method Area
- Heap
	- 객체, 배열 등 모든 스레드가 공유
	- GC : 불필요한 객체 제거
		- 자동으로 메모리 공간을 확보
		- [ ] 어떤 기준으로 확보하는지?
- Method Area

### Execution Engine

#### JIT Compiler
##### Interpreter
소스 코드를 한 행 씩 읽고 중간 코드로 번역하여 실행 

jit : 프로그램의 전체 실행 속도 향상
컴파일언어와 인터프리터 언어의 차이
자바는 컴파일인가 인터프리터 언어인가 → 주니어 면접에서 자주 물어봄 #정리필요 

#### GC
- 더 이상 참조되지 않는 객체들을 자동으로 검출하고 제거, 파이썬/자바스크립트 등에도 존재
    - 검출 :
    - 제거 : 메모리상 공간 확보
    - static 변수는 객체가 아니라서 가비지 컬렉터가 인식하지 않는건지?
        - 어디에 적재되는지, 언제 적재되는지, 왜 적재되는지 !
- 직접 관리하지 않아 번거롭진 않지만, 무조건 좋은가?
- 자동으로 검출하는 것도 리소스가 듦, 성능에 영향을 미침 → GC를 따로 튜닝하기도 함

### JVM 동작 간략 순서
1. JVM이 OS로부터 메모리를 할당받고 JVM은 할당받은 메모리를 여러 영역으로 나눠서 관리
2. 컴파일러로 소스코드를 읽어서 바이트코드로 변환
3. 클래스로더(링크)를 통해 바이트 코드 파일들을 JVM으로 로딩
4. 로딩된 클래스 파일들을 익스큐션 엔진에서 실행
5. 해석된 바이트코드는 메모리에 배치, 수행이 이루어짐 → 수행이 이뤄지는 과정에서 GC가 동작
